import os
import re
import sys
import m3u8
import json
import time
import pytz
import asyncio
import requests
import subprocess
import urllib
import urllib.parse
import yt_dlp
import tgcrypto
import cloudscraper
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from base64 import b64encode, b64decode
from logs import logging
from bs4 import BeautifulSoup
import ug as helper
from utils import progress_bar
from vars import *
from aiohttp import ClientSession
from subprocess import getstatusoutput
from pytube import YouTube
from aiohttp import web
import random
from pyromod import listen
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.errors import FloodWait
from pyrogram.errors.exceptions.bad_request_400 import MessageNotModified
from pyrogram.types.messages_and_media import message
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
import aiohttp
import aiofiles
import zipfile
import shutil
import ffmpeg
from datetime import datetime
from pyrogram.handlers import MessageHandler
from draw import create_text_watermark
from animation import *

from db import db
import auth  # Import auth module

from jbebwnqnwewwjn import get_apis

apis = get_apis()

# Initialize the bot
bot = Client(
    "botxx",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN
)

# Re-register auth commands
bot.add_handler(MessageHandler(auth.add_user_cmd, filters.command("add") & filters.private))
bot.add_handler(MessageHandler(auth.remove_user_cmd, filters.command("remove") & filters.private))
bot.add_handler(MessageHandler(auth.list_users_cmd, filters.command("users") & filters.private))
bot.add_handler(MessageHandler(auth.my_plan_cmd, filters.command("plan") & filters.private))

cookies_file_path = os.getenv("cookies_file_path", "youtube_cookies.txt")
api_url = "http://master-api-v3.vercel.app/"
api_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNzkxOTMzNDE5NSIsInRnX3VzZXJuYW1lIjoi4p61IFtvZmZsaW5lXSIsImlhdCI6MTczODY5MjA3N30.SXzZ1MZcvMp5sGESj0hBKSghhxJ3k1GTWoBUbivUe1I"
token_cp ='eyJjb3Vyc2VJZCI6IjQ1NjY4NyIsInR1dG9ySWQiOm51bGwsIm9yZ0lkIjo0ODA2MTksImNhdGVnb3J5SWQiOm51bGx9r'
adda_token = "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJkcGthNTQ3MEBnbWFpbC5jb20iLCJhdWQiOiIxNzg2OTYwNSIsImlhdCI6MTc0NDk0NDQ2NCwiaXNzIjoiYWRkYTI0Ny5jb20iLCJuYW1lIjoiZHBrYSIsImVtYWlsIjoiZHBrYTU0NzBAZ21haWwuY29tIiwicGhvbmUiOiI3MzUyNDA0MTc2IiwidXNlcklkIjoiYWRkYS52MS41NzMyNmRmODVkZDkxZDRiNDkxN2FiZDExN2IwN2ZjOCIsImxvZ2luQXBpVmVyc2lvbiI6MX0.0QOuYFMkCEdVmwMVIPeETa6Kxr70zEslWOIAfC_ylhbku76nDcaBoNVvqN4HivWNwlyT0jkUKjWxZ8AbdorMLg"
photologo = 'https://st2.depositphotos.com/38197074/44004/v/450/depositphotos_440042398-stock-illustration-initial-letter-vector-logo-icon.jpg' #https://envs.sh/GV0.jpg
photoyt = 'https://tinypic.host/images/2025/03/18/YouTube-Logo.wine.png' #https://envs.sh/GVi.jpg
photocp = 'https://tinypic.host/images/2025/03/28/IMG_20250328_133126.jpg'
photozip = 'https://envs.sh/cD_.jpg'


# Inline keyboard for start command
BUTTONSCONTACT = InlineKeyboardMarkup([[InlineKeyboardButton(text="üìû Contact", url="https://t.me/ITSUGBOT")]])
keyboard = InlineKeyboardMarkup(
    [
        [
            InlineKeyboardButton(text="üõ†Ô∏è Help", url="https://t.me/ITSUGBOT")        ],
    ]
)

# Image URLs for the random image feature
image_urls = [
    "https://st2.depositphotos.com/38197074/44004/v/450/depositphotos_440042398-stock-illustration-initial-letter-vector-logo-icon.jpg",
    "https://st2.depositphotos.com/38197074/44004/v/450/depositphotos_440042398-stock-illustration-initial-letter-vector-logo-icon.jpg",
    # Add more image URLs as needed
]

        
@bot.on_message(filters.command("cookies") & filters.private)
async def cookies_handler(client: Client, m: Message):
    await m.reply_text(
        "Please upload the cookies file (.txt format).",
        quote=True
    )

    try:
        # Wait for the user to send the cookies file
        input_message: Message = await client.listen(m.chat.id)

        # Validate the uploaded file
        if not input_message.document or not input_message.document.file_name.endswith(".txt"):
            await m.reply_text("Invalid file type. Please upload a .txt file.")
            return

        # Download the cookies file
        downloaded_path = await input_message.download()

        # Read the content of the uploaded file
        with open(downloaded_path, "r") as uploaded_file:
            cookies_content = uploaded_file.read()

        # Replace the content of the target cookies file
        with open(cookies_file_path, "w") as target_file:
            target_file.write(cookies_content)

        await input_message.reply_text(
            "‚úÖ Cookies updated successfully.\nüìÇ Saved in `youtube_cookies.txt`."
        )

    except Exception as e:
        await m.reply_text(f"‚ö†Ô∏è An error occurred: {str(e)}")

@bot.on_message(filters.command(["t2t"]))
async def text_to_txt(client, message: Message):
    user_id = str(message.from_user.id)
    # Inform the user to send the text data and its desired file name
    editable = await message.reply_text(f"<blockquote>Welcome to the Text to .txt Converter!\nSend the **text** for convert into a `.txt` file.</blockquote>")
    input_message: Message = await bot.listen(message.chat.id)
    if not input_message.text:
        await message.reply_text("**Send valid text data**")
        return

    text_data = input_message.text.strip()
    await input_message.delete()  # Corrected here
    
    await editable.edit("**üîÑ Send file name or send /d for filename**")
    inputn: Message = await bot.listen(message.chat.id)
    raw_textn = inputn.text
    await inputn.delete()  # Corrected here
    await editable.delete()

    if raw_textn == '/d':
        custom_file_name = 'txt_file'
    else:
        custom_file_name = raw_textn

    txt_file = os.path.join("downloads", f'{custom_file_name}.txt')
    os.makedirs(os.path.dirname(txt_file), exist_ok=True)  # Ensure the directory exists
    with open(txt_file, 'w') as f:
        f.write(text_data)
        
    await message.reply_document(document=txt_file, caption=f"`{custom_file_name}.txt`\n\n<blockquote>You can now download your content! üì•</blockquote>")
    os.remove(txt_file)

# Define paths for uploaded file and processed file
UPLOAD_FOLDER = '/path/to/upload/folder'
EDITED_FILE_PATH = '/path/to/save/edited_output.txt'

@bot.on_message(filters.command("getcookies") & filters.private)
async def getcookies_handler(client: Client, m: Message):
    try:
        # Send the cookies file to the user
        await client.send_document(
            chat_id=m.chat.id,
            document=cookies_file_path,
            caption="Here is the `youtube_cookies.txt` file."
        )
    except Exception as e:
        await m.reply_text(f"‚ö†Ô∏è An error occurred: {str(e)}")

@bot.on_message(filters.command(["stop"]) )
async def restart_handler(_, m):
    
    await m.reply_text("üö¶**STOPPED**", True)
    os.execl(sys.executable, sys.executable, *sys.argv)
        

@bot.on_message(filters.command("start"))
async def start(bot, m: Message):
    try:
        bot_username = bot.me.username
        user = db.get_user(m.from_user.id, bot_username)
    
        if not user or not db.is_user_authorized(m.from_user.id, bot_username):
            # Show unauthorized message
            start_message = await m.reply_photo(
                photo=photologo,
                caption=BotMessages.get_unauthorized_message(m.from_user.first_name),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üí´ Get Premium Access", url="https://t.me/ITSUGBOT")],
                [InlineKeyboardButton("‚ùì Help", callback_data="help_info")]
            ])
        )
            return
        
        # Show initial message for authorized users
        start_message = await m.reply_text("…™…¥…™·¥õ…™·¥Ä ü…™·¥¢…™…¥…¢ ·¥ò Ä·¥á·¥ç…™·¥ú·¥ç ·¥Ä·¥Ñ·¥Ñ·¥áss...")
        
        try:
            # Quick progress bar
            await BotMessages.show_progress(start_message)
            
            # Calculate days left and format expiry date
            expiry_date = user['expiry_date']
            if isinstance(expiry_date, str):
                expiry_date = datetime.strptime(expiry_date, "%Y-%m-%d %H:%M:%S")
            days_left = (expiry_date - datetime.now()).days
            
            # Show welcome message
            welcome_msg = BotMessages.get_welcome_message(
                m.from_user.first_name,
                days_left,
                expiry_date.strftime("%d-%m-%Y %H:%M:%S")
            )
            
            # Send new photo message with welcome message
            await start_message.delete()
            await m.reply_photo(
                photo=photologo,
                caption=welcome_msg,
        reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üì• ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö ·¥Ö Ä·¥ç", callback_data="start_drm")],
                    [
                        InlineKeyboardButton("üì¢ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥ás", url=PREMIUM_CHANNEL),
                        InlineKeyboardButton("üìû ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ", url="https://t.me/ITSUGBOT")
                    ]
                ])
            )
        except Exception as e:
            print(f"Error showing welcome message: {str(e)}")
            await start_message.edit_text(
                "‚ö†Ô∏è ·¥á Ä Ä·¥è Ä s ú·¥è·¥°…™…¥…¢ ·¥°·¥á ü·¥Ñ·¥è·¥ç·¥á ·¥ç·¥áss·¥Ä…¢·¥á. ·¥ò ü·¥á·¥Äs·¥á ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥  ü·¥Ä·¥õ·¥á Ä.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥", callback_data="refresh_start")]
                ])
            )
    except Exception as e:
        print(f"Error in start command: {str(e)}")
        await m.reply_text("‚ö†Ô∏è ·¥Ä…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö. ·¥ò ü·¥á·¥Äs·¥á ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥  ü·¥Ä·¥õ·¥á Ä.")

# Add callback handler for DRM button
@bot.on_callback_query(filters.regex("start_drm"))
async def start_drm(client, query):
    try:
        # Answer callback query immediately
        await query.answer()
        
        # Delete the original message
        await query.message.delete()
        
        # Create a message object with /drm command
        message = Message(
            id=0,  # Dummy ID
            chat=query.message.chat,
            from_user=query.from_user,
            text="/drmug",
            date=datetime.now(),
            client=client
        )
        
        # Call the drm command handler directly
        await txt_handler(client, message)
        
    except Exception as e:
        print(f"Error in DRM callback: {str(e)}")
        # Don't try to answer query again if there's an error
        await query.message.reply_text("‚ö†Ô∏è ·¥Ä…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö. ·¥ò ü·¥á·¥Äs·¥á ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥.")

def auth_check_filter(_, client, message):
    if not message.text or not message.text.startswith('/'):
        return True
        
    command = message.text.split()[0][1:].split('@')[0].lower()
    if command in ["start", "myplan"]:
        return True
        
    # Get bot username
    bot_username = client.me.username
        
    # Handle messages from channels
    if message.sender_chat:
        channel_id = message.sender_chat.id
        # Check if the channel is authorized
        channel = db.get_user(channel_id, bot_username)
        if channel and db.is_user_authorized(channel_id, bot_username):
            return True
        return False
        
    # Handle messages from users
    if message.from_user:
        user_id = message.from_user.id
        user = db.get_user(user_id, bot_username)
        if user and db.is_user_authorized(user_id, bot_username):
           return True
        
    return False

auth_filter = filters.create(auth_check_filter)

@bot.on_message(~auth_filter & filters.private & filters.command)
async def unauthorized_handler(client, message: Message):
    await message.reply(
        "<b>üîí Access Restricted</b>\n\n"
        "<blockquote>You need to have an active subscription to use this bot.\n"
        "Please contact admin to get premium access.</blockquote>",
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("üí´ Get Premium Access", url="https://t.me/ITSUGBOT")
        ]])
    )

@bot.on_message(filters.command(["id"]))
async def id_command(client, message: Message):
    chat_id = message.chat.id
    await message.reply_text(
        f"<blockquote>The ID of this chat id is:</blockquote>\n`{chat_id}`"
    )



@bot.on_message(filters.command(["drmug"]))
async def txt_handler(bot: Client, m: Message):  
    # Get bot username
    bot_info = await bot.get_me()
    bot_username = bot_info.username
  

 
    
    editable = await m.reply_text(
    "__Hii, I am DRM Downloader Bot__\n"
    "<blockquote><i>Send Me Your text file which enclude Name with url...\nE.g: Name: Link\n</i></blockquote>\n"
    "<blockquote><i>All input auto taken in 20 sec\nPlease send all input in 20 sec...\n</i></blockquote>",
    reply_markup=InlineKeyboardMarkup(
        [[
            InlineKeyboardButton("üëë Join Premium Group", url="https://t.me/ITSUGBOT")
        ]]
    )
)
    input: Message = await bot.listen(editable.chat.id)
    
    # Check if a document was actually sent
    if not input.document:
        await m.reply_text("<b>‚ùå Please send a text file!</b>")
        return
        
    # Check if it's a text file
    if not input.document.file_name.endswith('.txt'):
        await m.reply_text("<b>‚ùå Please send a .txt file!</b>")
        return
        
    x = await input.download()
    await input.delete(True)
    file_name, ext = os.path.splitext(os.path.basename(x))  # Extract filename & extension
    path = f"./downloads/{m.chat.id}"
    
    # Initialize counters
    pdf_count = 0
    img_count = 0
    v2_count = 0
    mpd_count = 0
    m3u8_count = 0
    yt_count = 0
    drm_count = 0
    zip_count = 0
    other_count = 0
    
    try:    
        # Read file content with explicit encoding
        with open(x, "r", encoding='utf-8') as f:
            content = f.read()
            
        # Debug: Print file content
        print(f"File content: {content[:500]}...")  # Print first 500 chars
            
        content = content.split("\n")
        content = [line.strip() for line in content if line.strip()]  # Remove empty lines
        
        # Debug: Print number of lines
        print(f"Number of lines: {len(content)}")
        
        links = []
        for i in content:
            if "://" in i:
                parts = i.split("://", 1)
                if len(parts) == 2:
                    name = parts[0]
                    url = parts[1]
                    links.append([name, url])
                    
                if ".pdf" in url:
                    pdf_count += 1
                elif url.endswith((".png", ".jpeg", ".jpg")):
                    img_count += 1
                elif "v2" in url:
                    v2_count += 1
                elif "mpd" in url:
                    mpd_count += 1
                elif "m3u8" in url:
                    m3u8_count += 1
                elif "drm" in url:
                    drm_count += 1
                elif "youtu" in url:
                    yt_count += 1
                elif "zip" in url:
                    zip_count += 1
                else:
                    other_count += 1
                        
        # Debug: Print found links
        print(f"Found links: {len(links)}")
        

        
    except UnicodeDecodeError:
        await m.reply_text("<b>‚ùå File encoding error! Please make sure the file is saved with UTF-8 encoding.</b>")
        os.remove(x)
        return
    except Exception as e:
        await m.reply_text(f"<b>üîπError reading file: {str(e)}</b>")
        os.remove(x)
        return
    
    await editable.edit(f"**Total üîó links found are {len(links)}\nPDF : {pdf_count}   Img : {img_count}   V2 : {v2_count} \nZIP : {zip_count}   Drm : {drm_count}   m3u8 : {m3u8_count}\nmpd : {mpd_count}   YT : {yt_count}\nOther : {other_count}\nSend From where you want to download. Initial is 1**")
    try:
        input0: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text = input0.text
        await input0.delete(True)
    except asyncio.TimeoutError:
        raw_text = '1'
    
    if int(raw_text) > len(links) :
        await editable.edit(f"**üîπEnter number in range of Index (01-{len(links)})**")
        processing_request = False  # Reset the processing flag
        await m.reply_text("**üîπExiting Task......  **")
        return
        
    await editable.edit(f"**Enter Batch Name or send /d**")
    try:
        input1: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text0 = input1.text
        await input1.delete(True)
    except asyncio.TimeoutError:
        raw_text0 = '/d'
    
    if raw_text0 == '/d':
        b_name = file_name.replace('_', ' ')
    else:
        b_name = raw_text0
    

    await editable.edit("__**Enter resolution or Video Quality (`144`, `240`, `360`, `480`, `720`, `1080`)**__")
    try:
        input2: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text2 = input2.text
        await input2.delete(True)
    except asyncio.TimeoutError:
        raw_text2 = '480'
    quality = f"{raw_text2}p"
    try:
        if raw_text2 == "144":
            res = "256x144"
        elif raw_text2 == "240":
            res = "426x240"
        elif raw_text2 == "360":
            res = "640x360"
        elif raw_text2 == "480":
            res = "854x480"
        elif raw_text2 == "720":
            res = "1280x720"
        elif raw_text2 == "1080":
            res = "1920x1080" 
        else: 
            res = "UN"
    except Exception:
            res = "UN"

    await editable.edit(f"__**Enter the Credit Name or send /d\nOr Send **Admin,file prename**\nSeparate them with a comma (,)\n\n<blockquote><i>Example for caption only: Admin\nExample for both caption and file name: Admin,Prename</i></blockquote>**")
    try:
        input3: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text3 = input3.text
        await input3.delete(True)
    except asyncio.TimeoutError:
        raw_text3 = '/d'
        
    if raw_text3 == '/d':
        CR = f"{CREDIT}"
    elif "," in raw_text3:
        CR, PRENAME = raw_text3.split(",")
    else:
        CR = raw_text3

    await editable.edit(f"**send the token of __PW__ or ClassPlus [Optional] OR send /d**")
    try:
        input4: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text4 = input4.text
        await input4.delete(True)
    except asyncio.TimeoutError:
        raw_text4 = '/d'
   
    await editable.edit(f"**Send the Video Thumb URL or send /d**")
    try:
        input6: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text6 = input6.text
        await input6.delete(True)
    except asyncio.TimeoutError:
        raw_text6 = '/d'
    
    
    await editable.edit("**Enter watermark text, /d for default, or 'no' for no watermark**")
    try:
        watermark_msg: Message = await bot.listen(editable.chat.id, timeout=20)
        watermark_text = watermark_msg.text
        await watermark_msg.delete(True)
    except asyncio.TimeoutError:
        watermark_text = "/d"

    # Handle watermark
    if watermark_text.lower() == "no":
        thumb = "/d"  # No watermark
    elif watermark_text == "/d":
        thumb = "/d"  # Use default wm.png
    else:
        # Create custom text watermark
        thumb = create_text_watermark(watermark_text)
        if not thumb:  # If watermark creation failed
            thumb = "/d"

    await editable.edit("__**‚ö†Ô∏èProvide the Channel ID or send /d__\n\n<blockquote><i>üîπ Make me an admin to upload.\nüî∏Send /id in your channel to get the Channel ID.\n\nExample: Channel ID = -100XXXXXXXXXXX</i></blockquote>\n**")
    try:
        input7: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text7 = input7.text
        await input7.delete(True)
    except asyncio.TimeoutError:
        raw_text7 = '/d'

    if "/d" in raw_text7:
        channel_id = m.chat.id
    else:
        channel_id = raw_text7    
    await editable.delete()

    try:
        if raw_text == "1":
            batch_message = await bot.send_message(chat_id=channel_id, text=f"<blockquote><b>üéØTarget Batch : {b_name}</b></blockquote>")
            if "/d" not in raw_text7:
                await bot.send_message(chat_id=m.chat.id, text=f"<blockquote><b><i>üéØTarget Batch : {b_name}</i></b></blockquote>\n\nüîÑ Your Task is under processing, please check your Set Channelüì±. Once your task is complete, I will inform you üì©")
                await bot.pin_chat_message(channel_id, batch_message.id)
                message_id = batch_message.id
                pinning_message_id = message_id + 1
                await bot.delete_messages(channel_id, pinning_message_id)
        else:
             if "/d" not in raw_text7:
                await bot.send_message(chat_id=m.chat.id, text=f"<blockquote><b><i>üéØTarget Batch : {b_name}</i></b></blockquote>\n\nüîÑ Your Task is under processing, please check your Set Channelüì±. Once your task is complete, I will inform you üì©")
    except Exception as e:
        await m.reply_text(f"**Fail Reason ¬ª**\n<blockquote><i>{e}</i></blockquote>\n\n‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}üåü`")

    failed_count = 0
    count =int(raw_text)    
    arg = int(raw_text)
    try:
        for i in range(arg-1, len(links)):
            Vxy = links[i][1].replace("file/d/","uc?export=download&id=").replace("www.youtube-nocookie.com/embed", "youtu.be").replace("?modestbranding=1", "").replace("/view?usp=sharing","")
            url = "https://" + Vxy
            link0 = "https://" + Vxy

            name1 = links[i][0].replace("(", "[").replace(")", "]").replace("_", "").replace("\t", "").replace(":", "").replace("/", "").replace("+", "").replace("#", "").replace("|", "").replace("@", "").replace("*", "").replace(".", "").replace("https", "").replace("http", "").strip()
            if "," in raw_text3:
                 name = f'{PRENAME} {name1[:60]}'
            else:
                 name = f'{name1[:60]}'
            
            if "visionias" in url:
                async with ClientSession() as session:
                    async with session.get(url, headers={'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'Accept-Language': 'en-US,en;q=0.9', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'Pragma': 'no-cache', 'Referer': 'http://www.visionias.in/', 'Sec-Fetch-Dest': 'iframe', 'Sec-Fetch-Mode': 'navigate', 'Sec-Fetch-Site': 'cross-site', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Linux; Android 12; RMX2121) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Mobile Safari/537.36', 'sec-ch-ua': '"Chromium";v="107", "Not=A?Brand";v="24"', 'sec-ch-ua-mobile': '?1', 'sec-ch-ua-platform': '"Android"',}) as resp:
                        text = await resp.text()
                        url = re.search(r"(https://.*?playlist.m3u8.*?)\"", text).group(1)

            if "acecwply" in url:
                cmd = f'yt-dlp -o "{name}.%(ext)s" -f "bestvideo[height<={raw_text2}]+bestaudio" --hls-prefer-ffmpeg --no-keep-video --remux-video mkv --no-warning "{url}"'

            elif "https://cpvod.testbook.com/" in url:
                url = url.replace("https://cpvod.testbook.com/","https://media-cdn.classplusapp.com/drm/")
                url = apis["API_DRM"] + url
                mpd, keys = helper.get_mps_and_keys(url)
                url = mpd
                keys_string = " ".join([f"--key {key}" for key in keys])

            elif "classplusapp.com/drm/" in url:
                print("\nüîê Detected DRM URL. Fetching keys via API...")

                api_url = apis["API_DRM"] + url
                retry_count = 0
                start_time = time.time()
                max_wait_time = 180  # Optional timeout (in seconds)

                while True:
                    try:
                        retry_count += 1
                        print(f"‚è≥ Attempt {retry_count}: Requesting DRM keys...")
                        mpd, keys = helper.get_mps_and_keys(api_url)

                        if mpd and keys:
                            url = mpd
                            keys_string = " ".join([f"--key {key}" for key in keys])
                            print("‚úÖ Successfully fetched DRM keys and MPD URL!")
                            break  # Exit loop
        
                        else:
                            print("‚ùå DRM keys not found in response. Retrying in 5 seconds...")
                            await asyncio.sleep(5)
        
                    except Exception as e:
                        print(f"‚ö†Ô∏è Error while fetching DRM keys: {e}")
                        print("üîÅ Retrying in 5 seconds...")
                        await asyncio.sleep(5)

            # Optional timeout check to avoid infinite hang
                        if time.time() - start_time > max_wait_time:
                            print("‚è∞ Timeout: Could not fetch DRM keys within 3 minutes.")
                            break


            elif 'media-cdn.classplusapp.com' in url or 'media-cdn-alisg.classplusapp.com' in url or 'media-cdn-a.classplusapp.com' in url or 'videos.classplusapp' in url or 'tencdn.classplusapp' in url: 
                if 'master.m3u8' in url:
                    print(f"Processing Classplus URL: {url}")
                    max_retries = 3  # Maximum number of retries
                    retry_count = 0
                    success = False
                    
                    # Check if raw_text4 is a valid JWT token (has 2 dots and longer than 30 chars)
                    is_valid_token = raw_text4 and raw_text4 != "/d" and raw_text4.count('.') == 2 and len(raw_text4) > 30
                    
                    while not success and retry_count < max_retries:
                        try:
                            # Only add token if it's valid JWT
                            params = {"url": url}
                            if is_valid_token:
                                params["token"] = raw_text4
                                print("Using provided JWT token")
                            
                            # First try with direct URL
                            response = requests.get(apis["API_CLASSPLUS"], params=params)
                            
                            if response.status_code == 200:
                                try:
                                    url = response.json().get("data", {}).get("url")
                                    if url and len(url) > 0:
                                        print(f"Got signed URL from classplusapp: {url}")
                                        cmd = None  # Don't use yt-dlp for m3u8 files
                                        success = True
                                        continue
                                except:
                                     pass
                            
                            # If direct URL failed, try refreshing token
                            print(f"Attempt {retry_count + 1} failed with status {response.status_code}")
                           
                        
                                
                        except Exception as e:
                            print(f"Attempt {retry_count + 1} failed with error: {str(e)}")
                            retry_count += 1
                            await asyncio.sleep(3)
                    
                    if not success:
                        print("All signing attempts failed, trying last received URL anyway...")

            elif "childId" in url and "parentId" in url:
                url = f"https://anonymousrajputplayer-9ab2f2730a02.herokuapp.com/pw?url={url}&token={raw_text4}"
                           
            elif "d1d34p8vz63oiq" in url or "sec1.pw.live" in url:
                url = f"https://anonymouspwplayer-b99f57957198.herokuapp.com/pw?url={url}?token={raw_text4}"

            if ".pdf*" in url:
                url = f"https://dragoapi.vercel.app/pdf/{url}"
            
            elif 'encrypted.m' in url:
                appxkey = url.split('*')[1]
                url = url.split('*')[0]

            if "youtu" in url:
                ytf = f"bv*[height<={raw_text2}][ext=mp4]+ba[ext=m4a]/b[height<=?{raw_text2}]"
            elif "embed" in url:
                ytf = f"bestvideo[height<={raw_text2}]+bestaudio/best[height<={raw_text2}]"
            else:
                ytf = f"b[height<={raw_text2}]/bv[height<={raw_text2}]+ba/b/bv+ba"
           
            if "jw-prod" in url:
                cmd = f'yt-dlp -o "{name}.mp4" "{url}"'
            elif "webvideos.classplusapp." in url:
               cmd = f'yt-dlp --add-header "referer:https://web.classplusapp.com/" --add-header "x-cdn-tag:empty" -f "{ytf}" "{url}" -o "{name}.mp4"'
            elif "youtube.com" in url or "youtu.be" in url:
                cmd = f'yt-dlp --cookies youtube_cookies.txt -f "{ytf}" "{url}" -o "{name}".mp4'
            else:
                cmd = f'yt-dlp -f "{ytf}" "{url}" -o "{name}.mp4"'

            try:
                cc = f'[üé•]Vid Id : {str(count).zfill(3)}\n**Video Title :** `{name1} [{res}p] .mkv`\n<blockquote><b>Batch Name :</b> {b_name}</blockquote>\n\n**Extracted by‚û§**{CR}\n'
                cc1 = f'[üìï]Pdf Id : {str(count).zfill(3)}\n**File Title :** `{name1} .pdf`\n<blockquote><b>Batch Name :</b> {b_name}</blockquote>\n\n**Extracted by‚û§**{CR}\n'
                cczip = f'[üìÅ]Zip Id : {str(count).zfill(3)}\n**Zip Title :** `{name1} .zip`\n<blockquote><b>Batch Name :</b> {b_name}</blockquote>\n\n**Extracted by‚û§**{CR}\n' 
                ccimg = f'[üñºÔ∏è]Img Id : {str(count).zfill(3)}\n**Img Title :** `{name1} .jpg`\n<blockquote><b>Batch Name :</b> {b_name}</blockquote>\n\n**Extracted by‚û§**{CR}\n'
                ccm = f'[üéµ]Audio Id : {str(count).zfill(3)}\n**Audio Title :** `{name1} .mp3`\n<blockquote><b>Batch Name :</b> {b_name}</blockquote>\n\n**Extracted by‚û§**{CR}\n'
                cchtml = f'[üåê]Html Id : {str(count).zfill(3)}\n**Html Title :** `{name1} .html`\n<blockquote><b>Batch Name :</b> {b_name}</blockquote>\n\n**Extracted by‚û§**{CR}\n'
                  
                if "drive" in url:
                    try:
                        ka = await helper.download(url, name)
                        copy = await bot.send_document(chat_id=channel_id,document=ka, caption=cc1)
                        count+=1
                        os.remove(ka)
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    
  
                elif ".pdf" in url:
                    if "cwmediabkt99" in url:
                        max_retries = 3  # Define the maximum number of retries
                        retry_delay = 4  # Delay between retries in seconds
                        success = False  # To track whether the download was successful
                        failure_msgs = []  # To keep track of failure messages
                        
                        for attempt in range(max_retries):
                            try:
                                await asyncio.sleep(retry_delay)
                                url = url.replace(" ", "%20")
                                scraper = cloudscraper.create_scraper()
                                response = scraper.get(url)

                                if response.status_code == 200:
                                    with open(f'{name}.pdf', 'wb') as file:
                                        file.write(response.content)
                                    await asyncio.sleep(retry_delay)  # Optional, to prevent spamming
                                    copy = await bot.send_document(chat_id=channel_id, document=f'{name}.pdf', caption=cc1)
                                    count += 1
                                    os.remove(f'{name}.pdf')
                                    success = True
                                    break  # Exit the retry loop if successful
                                else:
                                    failure_msg = await m.reply_text(f"Attempt {attempt + 1}/{max_retries} failed: {response.status_code} {response.reason}")
                                    failure_msgs.append(failure_msg)
                                    
                            except Exception as e:
                                failure_msg = await m.reply_text(f"Attempt {attempt + 1}/{max_retries} failed: {str(e)}")
                                failure_msgs.append(failure_msg)
                                await asyncio.sleep(retry_delay)
                                continue 
                        for msg in failure_msgs:
                            await msg.delete()
                            
                    else:
                        try:
                            cmd = f'yt-dlp -o "{name}.pdf" "{url}"'
                            download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                            os.system(download_cmd)
                            copy = await bot.send_document(chat_id=channel_id, document=f'{name}.pdf', caption=cc1)
                            count += 1
                            os.remove(f'{name}.pdf')
                        except FloodWait as e:
                            await m.reply_text(str(e))
                            time.sleep(e.x)
                            continue    

                elif ".ws" in url and  url.endswith(".ws"):
                    try:
                        await helper.pdf_download(f"{api_url}utkash-ws?url={url}&authorization={api_token}",f"{name}.html")
                        time.sleep(1)
                        await bot.send_document(chat_id=channel_id, document=f"{name}.html", caption=cchtml)
                        os.remove(f'{name}.html')
                        count += 1
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    
                            
                elif any(ext in url for ext in [".jpg", ".jpeg", ".png"]):
                    try:
                        ext = url.split('.')[-1]
                        cmd = f'yt-dlp -o "{name}.{ext}" "{url}"'
                        download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                        os.system(download_cmd)
                        copy = await bot.send_photo(chat_id=channel_id, photo=f'{name}.{ext}', caption=ccimg)
                        count += 1
                        os.remove(f'{name}.{ext}')
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    

                elif any(ext in url for ext in [".mp3", ".wav", ".m4a"]):
                    try:
                        ext = url.split('.')[-1]
                        cmd = f'yt-dlp -x --audio-format {ext} -o "{name}.{ext}" "{url}"'
                        download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                        os.system(download_cmd)
                        await bot.send_document(chat_id=channel_id, document=f'{name}.{ext}', caption=cc1)
                        os.remove(f'{name}.{ext}')
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    
                    
                elif 'encrypted.m' in url:    
                    Show = f"<i><b>Video Downloading</b></i>\n<blockquote><b>{str(count).zfill(3)}) {name1}</b></blockquote>"
                    prog = await bot.send_message(channel_id, Show, disable_web_page_preview=True)
                    res_file = await helper.download_and_decrypt_video(url, cmd, name, appxkey)  
                    filename = res_file  
                    await prog.delete(True)  
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    count += 1  
                    await asyncio.sleep(1)  
                    continue  

                elif 'drmcdni' in url or 'drm/wv' in url:
                    Show = f"<i><b>Video Downloading</b></i>\n<blockquote><b>{str(count).zfill(3)}) {name1}</b></blockquote>"
                    prog = await bot.send_message(channel_id, Show, disable_web_page_preview=True)
                    res_file = await helper.decrypt_and_merge_video(mpd, keys_string, path, name, raw_text2)
                    filename = res_file
                    await prog.delete(True)
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    count += 1
                    await asyncio.sleep(1)
                    continue
     
             

             
                else:
                    Show = f"<i><b>Video Downloading</b></i>\n<blockquote><b>{str(count).zfill(3)}) {name1}</b></blockquote>"
                    prog = await bot.send_message(channel_id, Show, disable_web_page_preview=True)
                    res_file = await helper.download_video(url, cmd, name)
                    filename = res_file
                    await prog.delete(True)
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    count += 1
                    time.sleep(1)
                
            except Exception as e:
                await bot.send_message(channel_id, f'‚ö†Ô∏è**Downloading Failed**‚ö†Ô∏è\n**Name** =>> `{str(count).zfill(3)} {name1}`\n**Url** =>> {link0}\n\n<blockquote><i><b>Failed Reason: {str(e)}</b></i></blockquote>', disable_web_page_preview=True)
                count += 1
                failed_count += 1
                continue

    except Exception as e:
        await m.reply_text(e)
        time.sleep(2)

    success_count = len(links) - failed_count
    video_count = v2_count + mpd_count + m3u8_count + yt_count + drm_count + zip_count + other_count
    if raw_text7 == "/d":
        await bot.send_message(channel_id, f"<b>-‚îà‚îÅ‚ïê.‚Ä¢¬∞‚úÖ Completed ‚úÖ¬∞‚Ä¢.‚ïê‚îÅ‚îà-</b>\n<blockquote><b>üéØBatch Name : {b_name}</b></blockquote>\n<blockquote>üîó Total URLs: {len(links)} \n‚îÉ   ‚î†üî¥ Total Failed URLs: {failed_count}\n‚îÉ   ‚î†üü¢ Total Successful URLs: {success_count}\n‚îÉ   ‚îÉ   ‚î†üé• Total Video URLs: {video_count}\n‚îÉ   ‚îÉ   ‚î†üìÑ Total PDF URLs: {pdf_count}\n‚îÉ   ‚îÉ   ‚î†üì∏ Total IMAGE URLs: {img_count}</blockquote>\n")
    else:
        await bot.send_message(channel_id, f"<b>-‚îà‚îÅ‚ïê.‚Ä¢¬∞‚úÖ Completed ‚úÖ¬∞‚Ä¢.‚ïê‚îÅ‚îà-</b>\n<blockquote><b>üéØBatch Name : {b_name}</b></blockquote>\n<blockquote>üîó Total URLs: {len(links)} \n‚îÉ   ‚î†üî¥ Total Failed URLs: {failed_count}\n‚îÉ   ‚î†üü¢ Total Successful URLs: {success_count}\n‚îÉ   ‚îÉ   ‚î†üé• Total Video URLs: {video_count}\n‚îÉ   ‚îÉ   ‚î†üìÑ Total PDF URLs: {pdf_count}\n‚îÉ   ‚îÉ   ‚î†üì∏ Total IMAGE URLs: {img_count}</blockquote>\n")
        await bot.send_message(m.chat.id, f"<blockquote><b>‚úÖ Your Task is completed, please check your Set Channelüì±</b></blockquote>")


@bot.on_message(filters.text & filters.private)
async def text_handler(bot: Client, m: Message):
    if m.from_user.is_bot:
        return
    links = m.text
    path = None
    match = re.search(r'https?://\S+', links)
    if match:
        link = match.group(0)
    else:
        await m.reply_text("<pre><code>Invalid link format.</code></pre>")
        return
        
    editable = await m.reply_text(f"<pre><code>**üîπProcessing your link...\nüîÅPlease wait...‚è≥**</code></pre>")
    await m.delete()

    await editable.edit(f"‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚ù∞·¥á…¥·¥õ·¥á Ä  Ä·¥áÍú±·¥è ü·¥ú·¥õ…™·¥è…¥‚ù±‚îÅ‚îÅ‚û£ \n‚î£‚îÅ‚îÅ‚™º send `144`  for 144p\n‚î£‚îÅ‚îÅ‚™º send `240`  for 240p\n‚î£‚îÅ‚îÅ‚™º send `360`  for 360p\n‚î£‚îÅ‚îÅ‚™º send `480`  for 480p\n‚î£‚îÅ‚îÅ‚™º send `720`  for 720p\n‚î£‚îÅ‚îÅ‚™º send `1080` for 1080p\n‚ï∞‚îÅ‚îÅ‚åà‚ö°[`{CREDIT}`]‚ö°‚åã‚îÅ‚îÅ‚û£ ")
    input2: Message = await bot.listen(editable.chat.id, filters=filters.text & filters.user(m.from_user.id))
    raw_text2 = input2.text
    quality = f"{raw_text2}p"
    await input2.delete(True)
    try:
        if raw_text2 == "144":
            res = "256x144"
        elif raw_text2 == "240":
            res = "426x240"
        elif raw_text2 == "360":
            res = "640x360"
        elif raw_text2 == "480":
            res = "854x480"
        elif raw_text2 == "720":
            res = "1280x720"
        elif raw_text2 == "1080":
            res = "1920x1080" 
        else: 
            res = "UN"
    except Exception:
            res = "UN"
          
   
    raw_text4 = "working_token"
    thumb = "/d"
    count =0
    arg =1
    channel_id = m.chat.id
    try:
            Vxy = link.replace("file/d/","uc?export=download&id=").replace("www.youtube-nocookie.com/embed", "youtu.be").replace("?modestbranding=1", "").replace("/view?usp=sharing","")
            url = Vxy

            name1 = links.replace("(", "[").replace(")", "]").replace("_", "").replace("\t", "").replace(":", "").replace("/", "").replace("+", "").replace("#", "").replace("|", "").replace("@", "").replace("*", "").replace(".", "").replace("https", "").replace("http", "").strip()
            name = f'{name1[:60]}'
            
            if "visionias" in url:
                async with ClientSession() as session:
                    async with session.get(url, headers={'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'Accept-Language': 'en-US,en;q=0.9', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'Pragma': 'no-cache', 'Referer': 'http://www.visionias.in/', 'Sec-Fetch-Dest': 'iframe', 'Sec-Fetch-Mode': 'navigate', 'Sec-Fetch-Site': 'cross-site', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Linux; Android 12; RMX2121) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Mobile Safari/537.36', 'sec-ch-ua': '"Chromium";v="107", "Not=A?Brand";v="24"', 'sec-ch-ua-mobile': '?1', 'sec-ch-ua-platform': '"Android"',}) as resp:
                        text = await resp.text()
                        url = re.search(r"(https://.*?playlist.m3u8.*?)\"", text).group(1)

            if "acecwply" in url:
                cmd = f'yt-dlp -o "{name}.%(ext)s" -f "bestvideo[height<={raw_text2}]+bestaudio" --hls-prefer-ffmpeg --no-keep-video --remux-video mkv --no-warning "{url}"'

            elif "https://cpvod.testbook.com/" in url:
                url = url.replace("https://cpvod.testbook.com/","https://media-cdn.classplusapp.com/drm/")
                url = apis["API_DRM"] + url
                mpd, keys = helper.get_mps_and_keys(url)
                url = mpd
                keys_string = " ".join([f"--key {key}" for key in keys])


            elif "classplusapp.com/drm/" in url:
                print("\nüîê Detected DRM URL. Fetching keys via API...")

                api_url = apis["API_DRM"] + url
                retry_count = 0
                start_time = time.time()
                max_wait_time = 180  # Optional timeout (in seconds)

                while True:
                    try:
                        retry_count += 1
                        print(f"‚è≥ Attempt {retry_count}: Requesting DRM keys...")
                        mpd, keys = helper.get_mps_and_keys(api_url)

                        if mpd and keys:
                            url = mpd
                            keys_string = " ".join([f"--key {key}" for key in keys])
                            print("‚úÖ Successfully fetched DRM keys and MPD URL!")
                            break  # Exit loop
        
                        else:
                            print("‚ùå DRM keys not found in response. Retrying in 5 seconds...")
                            await asyncio.sleep(5)
        
                    except Exception as e:
                        print(f"‚ö†Ô∏è Error while fetching DRM keys: {e}")
                        print("üîÅ Retrying in 5 seconds...")
                        await asyncio.sleep(5)

    

            elif 'media-cdn.classplusapp.com' in url or 'media-cdn-alisg.classplusapp.com' in url or 'media-cdn-a.classplusapp.com' in url or 'videos.classplusapp' in url or 'tencdn.classplusapp' in url: 
                if 'master.m3u8' in url:
                    print(f"Processing Classplus URL: {url}")
                    max_retries = 3  # Maximum number of retries
                    retry_count = 0
                    success = False
                    
                    # Check if raw_text4 is a valid JWT token (has 2 dots and longer than 30 chars)
                    is_valid_token = raw_text4 and raw_text4 != "/d" and raw_text4.count('.') == 2 and len(raw_text4) > 30
                    
                    while not success and retry_count < max_retries:
                        try:
                            # Only add token if it's valid JWT
                            params = {"url": url}
                            if is_valid_token:
                                params["token"] = raw_text4
                                print("Using provided JWT token")
                            
                            # First try with direct URL
                            response = requests.get(apis["API_CLASSPLUS"], params=params)
                            
                            if response.status_code == 200:
                                try:
                                    url = response.json().get("data", {}).get("url")
                                    if url and len(url) > 0:
                                        print(f"Got signed URL from classplusapp: {url}")
                                        cmd = None  # Don't use yt-dlp for m3u8 files
                                        success = True
                                        continue
                                except:
                                    pass
                        
                            # If direct URL failed, try refreshing token
                            print(f"Attempt {retry_count + 1} failed with status {response.status_code}")
                            
                           
                            
                        except Exception as e:
                            print(f"Attempt {retry_count + 1} failed with error: {str(e)}")
                            retry_count += 1
                            await asyncio.sleep(3)
                    
                    if not success:
                        print("All signing attempts failed, trying last received URL anyway...")

            elif "childId" in url and "parentId" in url:
                    url = f"https://anonymousrajputplayer-9ab2f2730a02.herokuapp.com/pw?url={url}&token={raw_text4}"
                           
            elif "d1d34p8vz63oiq" in url or "sec1.pw.live" in url:
                url = f"https://anonymouspwplayer-b99f57957198.herokuapp.com/pw?url={url}?token={raw_text4}"
                
            if ".pdf*" in url:
                url = f"https://dragoapi.vercel.app/pdf/{url}"
            
            elif 'encrypted.m' in url:
                appxkey = url.split('*')[1]
                url = url.split('*')[0]

            if "youtu" in url:
                ytf = f"bv*[height<={raw_text2}][ext=mp4]+ba[ext=m4a]/b[height<=?{raw_text2}]"
            elif "embed" in url:
                ytf = f"bestvideo[height<={raw_text2}]+bestaudio/best[height<={raw_text2}]"
            else:
                ytf = f"b[height<={raw_text2}]/bv[height<={raw_text2}]+ba/b/bv+ba"
           
            if "jw-prod" in url:
                cmd = f'yt-dlp -o "{name}.mp4" "{url}"'
            elif "webvideos.classplusapp." in url:
               cmd = f'yt-dlp --add-header "referer:https://web.classplusapp.com/" --add-header "x-cdn-tag:empty" -f "{ytf}" "{url}" -o "{name}.mp4"'
            elif "youtube.com" in url or "youtu.be" in url:
                cmd = f'yt-dlp --cookies youtube_cookies.txt -f "{ytf}" "{url}" -o "{name}".mp4'
            else:
                cmd = f'yt-dlp -f "{ytf}" "{url}" -o "{name}.mp4"'

            try:
                cc = f'üéûÔ∏èùêìùê¢ùê≠ùê•ùêû ¬ª `{name} [{res}].mp4`\nüîóùêãùê¢ùêßùê§ ¬ª <a href="{link}">__**CLICK HERE**__</a>\n\nüåüùêÑùê±ùê≠ùê´ùêöùêúùê≠ùêûùêù ùêÅùê≤ ¬ª `{CREDIT}`'
                cc1 = f'üìïùêìùê¢ùê≠ùê•ùêû ¬ª `{name}`\nüîóùêãùê¢ùêßùê§ ¬ª <a href="{link}">__**CLICK HERE**__</a>\n\nüåüùêÑùê±ùê≠ùê´ùêöùêúùê≠ùêûùêù ùêÅùê≤ ¬ª `{CREDIT}`'
                  
                if "drive" in url:
                    try:
                        ka = await helper.download(url, name)
                        copy = await bot.send_document(chat_id=m.chat.id,document=ka, caption=cc1)
                        count+=1
                        os.remove(ka)
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        pass

                elif ".pdf" in url:
                    if "cwmediabkt99" in url:
                        max_retries = 15  # Define the maximum number of retries
                        retry_delay = 4  # Delay between retries in seconds
                        success = False  # To track whether the download was successful
                        failure_msgs = []  # To keep track of failure messages
                        
                        for attempt in range(max_retries):
                            try:
                                await asyncio.sleep(retry_delay)
                                url = url.replace(" ", "%20")
                                scraper = cloudscraper.create_scraper()
                                response = scraper.get(url)

                                if response.status_code == 200:
                                    with open(f'{name}.pdf', 'wb') as file:
                                        file.write(response.content)
                                    await asyncio.sleep(retry_delay)  # Optional, to prevent spamming
                                    copy = await bot.send_document(chat_id=m.chat.id, document=f'{name}.pdf', caption=cc1)
                                    os.remove(f'{name}.pdf')
                                    success = True
                                    break  # Exit the retry loop if successful
                                else:
                                    failure_msg = await m.reply_text(f"Attempt {attempt + 1}/{max_retries} failed: {response.status_code} {response.reason}")
                                    failure_msgs.append(failure_msg)
                                    
                            except Exception as e:
                                failure_msg = await m.reply_text(f"Attempt {attempt + 1}/{max_retries} failed: {str(e)}")
                                failure_msgs.append(failure_msg)
                                await asyncio.sleep(retry_delay)
                                continue 

                        # Delete all failure messages if the PDF is successfully downloaded
                        for msg in failure_msgs:
                            await msg.delete()
                            
                        if not success:
                            # Send the final failure message if all retries fail
                            await m.reply_text(f"Failed to download PDF after {max_retries} attempts.\n‚ö†Ô∏è**Downloading Failed**‚ö†Ô∏è\n**Name** =>> {str(count).zfill(3)} {name1}\n**Url** =>> {link0}", disable_web_page_preview)
                            
                    else:
                        try:
                            cmd = f'yt-dlp -o "{name}.pdf" "{url}"'
                            download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                            os.system(download_cmd)
                            copy = await bot.send_document(chat_id=m.chat.id, document=f'{name}.pdf', caption=cc1)
                            os.remove(f'{name}.pdf')
                        except FloodWait as e:
                            await m.reply_text(str(e))
                            time.sleep(e.x)
                            pass   

                elif any(ext in url for ext in [".mp3", ".wav", ".m4a"]):
                    try:
                        ext = url.split('.')[-1]
                        cmd = f'yt-dlp -x --audio-format {ext} -o "{name}.{ext}" "{url}"'
                        download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                        os.system(download_cmd)
                        await bot.send_document(chat_id=m.chat.id, document=f'{name}.{ext}', caption=cc1)
                        os.remove(f'{name}.{ext}')
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        pass

                elif any(ext in url for ext in [".jpg", ".jpeg", ".png"]):
                    try:
                        ext = url.split('.')[-1]
                        cmd = f'yt-dlp -o "{name}.{ext}" "{url}"'
                        download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                        os.system(download_cmd)
                        copy = await bot.send_photo(chat_id=m.chat.id, photo=f'{name}.{ext}', caption=cc1)
                        count += 1
                        os.remove(f'{name}.{ext}')
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        pass
                                
                elif 'encrypted.m' in url:    
                    Show = f"**‚ö°D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ S·¥õ·¥Ä Ä·¥õ·¥á·¥Ö...‚è≥**\n" \
                           f"üîóùêãùê¢ùêßùê§ ¬ª {url}\n" \
                           f"‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}"
                    prog = await m.reply_text(Show, disable_web_page_preview=True)
                    res_file = await helper.download_and_decrypt_video(url, cmd, name, appxkey)  
                    filename = res_file  
                    await prog.delete(True)  
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    await asyncio.sleep(1)  
                    pass

                elif 'drmcdni' in url or 'drm/wv' in url:
                    Show = f"**‚ö°D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ S·¥õ·¥Ä Ä·¥õ·¥á·¥Ö...‚è≥**\n" \
                           f"üîóùêãùê¢ùêßùê§ ¬ª {url}\n" \
                           f"‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}"
                    prog = await m.reply_text(Show, disable_web_page_preview=True)
                    res_file = await helper.decrypt_and_merge_video(mpd, keys_string, path, name, raw_text2)
                    filename = res_file
                    await prog.delete(True)
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    await asyncio.sleep(1)
                    pass

                else:
                    Show = f"**‚ö°D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ S·¥õ·¥Ä Ä·¥õ·¥á·¥Ö...‚è≥**\n" \
                           f"üîóùêãùê¢ùêßùê§ ¬ª {url}\n" \
                           f"‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}"
                    prog = await m.reply_text(Show, disable_web_page_preview=True)
                    res_file = await helper.download_video(url, cmd, name)
                    filename = res_file
                    await prog.delete(True)
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    time.sleep(1)
                
            except Exception as e:
                    await m.reply_text(f"‚ö†Ô∏èùêÉùê®ùê∞ùêßùê•ùê®ùêöùêùùê¢ùêßùê† ùêàùêßùê≠ùêûùê´ùêÆùê©ùê≠ùêûùêù\n\nüîóùêãùê¢ùêßùê§ ¬ª `{link}`\n\n<blockquote><b><i>‚ö†Ô∏èFailed Reason ¬ª**__\n{str(e)}</i></b></blockquote>")
                    pass

    except Exception as e:
        await m.reply_text(str(e))

# Add callback handler for Help button
@bot.on_callback_query(filters.regex("help_info"))
async def help_info(client, query):
    try:
        # Answer callback query immediately
        await query.answer()
        
        help_text = (
            "**üî∞ Bot Help & Information**\n\n"
            "<blockquote>This is a premium bot with advanced features:\n"
            "‚Ä¢ üìö Appx Zip+Encrypted Url\n"
            "‚Ä¢ üéì Classplus DRM+ NDRM\n"
            "‚Ä¢ üßë‚Äçüè´ PhysicsWallah DRM\n"
            "‚Ä¢ üìö CareerWill + PDF\n"
            "And many more...</blockquote>\n\n"
            "<i>Contact admin to get subscription access</i>"
        )
        
        await query.message.edit_text(
            help_text,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üí´ Get Premium Access", url="https://t.me/ITSUGBOT")],
                [InlineKeyboardButton("üîô Back", callback_data="refresh_start")]
            ])
        )
        
    except Exception as e:
        print(f"Error in help callback: {str(e)}")
        await query.message.reply_text("‚ö†Ô∏è ·¥Ä…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö. ·¥ò ü·¥á·¥Äs·¥á ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥.")

# Add callback handler for Refresh button
@bot.on_callback_query(filters.regex("refresh_start"))
async def refresh_start(client, query):
    try:
        # Answer callback query immediately
        await query.answer()
        
        # Get user info
        bot_username = client.me.username
        user = db.get_user(query.from_user.id, bot_username)
        
        if not user or not db.is_user_authorized(query.from_user.id, bot_username):
            await query.message.edit_text(
                BotMessages.get_unauthorized_message(query.from_user.first_name),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üí´ Get Premium Access", url="https://t.me/ITSUGBOT")],
                    [InlineKeyboardButton("‚ùì Help", callback_data="help_info")]
                ])
            )
            return
        
        # Calculate days left and format expiry date
        expiry_date = user['expiry_date']
        if isinstance(expiry_date, str):
            expiry_date = datetime.strptime(expiry_date, "%Y-%m-%d %H:%M:%S")
        days_left = (expiry_date - datetime.now()).days
        
        # Show welcome message
        welcome_msg = BotMessages.get_welcome_message(
            query.from_user.first_name,
            days_left,
            expiry_date.strftime("%d-%m-%Y %H:%M:%S")
        )
        
        await query.message.edit_text(
            welcome_msg,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üì• ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö ·¥Ö Ä·¥ç", callback_data="start_drm")],
                [
                    InlineKeyboardButton("üì¢ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥ás", url=PREMIUM_CHANNEL),
                    InlineKeyboardButton("üìû ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ", url="https://t.me/ITSUGBOT")
                ]
            ])
        )
        
    except Exception as e:
        print(f"Error in refresh callback: {str(e)}")
        await query.message.reply_text("‚ö†Ô∏è ·¥Ä…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö. ·¥ò ü·¥á·¥Äs·¥á ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥.")

bot.run()03-Jul-25 00:53:14 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 00:56:24 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 00:57:47 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:17:24 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:21:37 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:29:52 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:38:35 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:39:35 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:45:45 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:50:57 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:56:27 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:58:04 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 01:58:48 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:00:46 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:08:33 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:14:33 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:15:02 - ERROR - Unhandled exception: name 'auto_clicked' is not defined [dispatcher.py:403]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 370, in _process_packet
    await self._execute_callback(handler, parsed_update)
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 407, in _execute_callback
    await handler.callback(self.client, *args)
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\handlers\message_handler.py", line 154, in resolve_future_or_callback
    await self.original_callback(client, message, *args)
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyromod\listen\listen.py", line 93, in resolve_listener
    await self.user_callback(client, message, *args)
  File "C:\Users\User\Documents\UGDEVUploader-main\main.py", line 504, in txt_handler
    timeout_duration = 2 if auto_clicked else 20
NameError: name 'auto_clicked' is not defined
03-Jul-25 02:17:51 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:22:07 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:30:05 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:32:55 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
03-Jul-25 02:39:40 - ERROR - Task exception was never retrieved
future: <Task finished name='Task-1' coro=<Dispatcher.add_handler.<locals>.fn() done, defined at C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py:296> exception=TypeError("'<' not supported between instances of 'function' and 'int'")> [base_events.py:1758]
Traceback (most recent call last):
  File "C:\Users\User\AppData\Local\Programs\Python\Python310\lib\site-packages\pyrogram\dispatcher.py", line 307, in fn
    self.groups = OrderedDict(sorted(self.groups.items()))
TypeError: '<' not supported between instances of 'function' and 'int'
